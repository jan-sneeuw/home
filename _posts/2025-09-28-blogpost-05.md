---
title: "Reverse Engineering a Crackme"
excerpt: A walkthrough of how I cracked a password input using buffer overflows.
date: 2025-09-28
---

Recently, I am trying to learn more about reverse engineering in cybersecurity. Instead of diving head-first into malware-analysis (which is relatively involved), I decided to tackle a few easier toy problems that don't necessarily have anything to do with malware yet.

I stumbled upon the website [https://crackmes.one/](https://crackmes.one/) and chose a fairly easy problem, namely [fdisotto's good_boy](https://crackmes.one/crackme/669a714890c4c2830c820bc0). All the information that we are given is that the executable is written in C/C++. The task is to find the correct password.

After downloading and unzipping the file, we can naively run some tests, like running a few test passwords:
```console
$ ./good_boy 
Enter the password: 123456
Bad boy!
```
As a next step, I tried using the GNU Debugger (GDB) to look for anything useful:
```console
$ gdb ./good_boy
```
Unfortunately, this gave nothing relevant, in fact it did not even return any assembly code. My next attempt involved trying all kinds of special characters, like `ÖÄ!"§$%&/()=¸¹²²³¼¼{½¬`, and I tried feeding the input a file containing the character `1` around ~5000 times as one long string to look for any overflow issues. Nonetheless, the executable always returned `Bad boy!`.

The next idea was to use an online C-decompiler, in order to analyse the program in detail. I used [dogbolt.org](https://dogbolt.org/) to upload `good_boy` and view the decompiled code with BinaryNinja. The entire file is quite long with 153 lines of code, most of which being irrelevant for our analysis. The only part that we need to look at in more depth is the following snippet:
```c
int32_t main(int32_t argc, char** argv, char** envp)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    __printf_chk(1, "Enter the password: ", 0x72);
    int32_t var_118;
    __isoc99_scanf("%255s", &var_118);
    int16_t var_114;

    if (0x30783468 == var_118 && 0x72 == var_114)
        puts("Good boy!");
    else
        puts("Bad boy!");

    *(fsbase + 0x28);

    if (rax == *(fsbase + 0x28))
        return 0;

    __stack_chk_fail();
    /* no return */
}
```
Notice that the interesting bit starts after the line `__printf_chk(1, "Enter the password: ", 0x72);`. First, a 32-bit integer called `var_118` is declared. In the next line, we see that we can interpret this variable as the user input, in the `__isoc99_scanf` function. The parameter `"%255s` tells us that the password may consist of 255 characters. The hexadecimal string `0x30783468` can be converted to ASCII characters as `0x4h`, but since the original string is laid out least significant byte first in memory, it rather translates to `h4x0`. Now we find that `0x72` converts to `r` in ASCII, so all in all we can make the educated guess that the correct password should be `h4x0r`:
```console
$ ./good_boy 
Enter the password: h4x0r
Good boy!
```
So we see that this does indeed solve the crackme puzzle.

TODO: Explanantion why this works!



