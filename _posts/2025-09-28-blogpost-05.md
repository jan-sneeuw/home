---
title: "Reverse Engineering a Crackme"
excerpt: A walkthrough of how I cracked a password input using buffer overflows.
date: 2025-09-28
---

Recently, I am trying to learn more about reverse engineering in cybersecurity. Instead of diving head-first into malware-analysis (which is relatively involved), I decided to tackle a few easier toy problems that don't necessarily have anything to do with malware yet.

I stumbled upon the website [https://crackmes.one/](https://crackmes.one/) and chose a fairly easy problem, namely [fdisotto's good_boy](https://crackmes.one/crackme/669a714890c4c2830c820bc0). All the information that we are given is that the executable is written in C/C++. The task is to find the correct password.

After downloading and unzipping the file, we can naively run some tests, like running a few test passwords:
```console
$ ./good_boy 
Enter the password: 123456
Bad boy!
```
As a next step, I tried using the GNU Debugger (GDB) to look for anything useful:
```console
$ gdb ./good_boy
```
Unfortunately, this gave nothing relevant, in fact it did not even return any assembly code. My next attempt involved trying all kinds of special characters, like `ÖÄ!"§$%&/()=¸¹²²³¼¼{½¬`, and I tried feeding the input a file containing the character `1` around ~5000 times as one long string to look for any overflow issues. Nonetheless, the executable always returned `Bad boy!`.

The next idea was to use an online C-decompiler, in order to analyse the program in detail. I used [dogbolt.org](https://dogbolt.org/) to upload `good_boy` and view the decompiled code with BinaryNinja. The entire file is quite long with 153 lines of code, most of which being irrelevant for our analysis. The only part that we need to look at in more depth is the following snippet:
```c
int32_t main(int32_t argc, char** argv, char** envp)
{
    void* fsbase;
    int64_t rax = *(fsbase + 0x28);
    __printf_chk(1, "Enter the password: ", 0x72);
    int32_t var_118;
    __isoc99_scanf("%255s", &var_118);
    int16_t var_114;

    if (0x30783468 == var_118 && 0x72 == var_114)
        puts("Good boy!");
    else
        puts("Bad boy!");

    *(fsbase + 0x28);

    if (rax == *(fsbase + 0x28))
        return 0;

    __stack_chk_fail();
    /* no return */
}
```
Keep in mind that this snippet is not an exact replica of the actual executable, because decompilers can only return interpretations or best-guesses of what the program does. For instance, you will see later that an integer `var_118` is declared but later all kinds of characters can be written into it, which obviously cannot happen in the strict sense. 

Notice that the interesting bit starts after the line `__printf_chk(1, "Enter the password: ", 0x72);`. First, a 32-bit integer called `var_118` is declared. In the next line, we see that we can interpret this variable as the user input, in the `__isoc99_scanf` function. The parameter `"%255s` tells us that the password may consist of 255 characters. The hexadecimal string `0x30783468` can be converted to ASCII characters as `0x4h`, but since the original string is laid out least significant byte first in memory, it rather translates to `h4x0`. Now we find that `0x72` converts to `r` in ASCII, so all in all we can make the educated guess that the correct password should be `h4x0r`:
```console
$ ./good_boy 
Enter the password: h4x0r
Good boy!
```
Indeed, we see that this solves the crackme puzzle.

So why exactly does this password work? First, remember that `var_118` was a 32-bit integer, i.e. it consists of 4-bytes, or 4 characters, and thus we expect to induce a buffer overflow if the password is longer than 4 characters. When we type `h4x0r`, the character `r` overflows into the `var_114` integer, and so the program outputs "Good boy!".

Since this was a fairly easy exercise, we could have just written a script to brute-force the password. One attempt at this is the following bash snippet which I calle `brute.sh`:
```bash
#!/bin/bash

count=0
while read pw; do
    count=$((count+1))

    # Send the password into the program
    output=$(printf "%s\n" "$pw" | ./good_boy 2>/dev/null)

    # Update progress every 1000 attempts
    if (( count % 1000 == 0 )); then
        echo "Tried $count passwords so far..."
    fi

    # Check if it prints the string "Good boy!"
    if echo "$output" | grep -q "Good boy!"; then
        echo "FOUND PASSWORD: $pw (after $count attempts)"
        break
    fi
done < /PATH/TO/rockyou.txt
```
This binary simply runs through the classic password textfile rockyou.txt and tells us when the correct password has been guessed. Obviously this is very inefficient in most cases, we just happened to be lucky in this exercise. In the CLI, this looks as follows:
```console
$ ./brute.sh 
Tried 1000 passwords so far...
Tried 2000 passwords so far...
Tried 3000 passwords so far...
...
Tried 8000 passwords so far...
FOUND PASSWORD: h4x0r (after 8676 attempts)
```

For the idea about looking at buffer overflows, I followed a helpful [video](https://www.youtube.com/watch?v=W1okWEzGAGo) on Youtube, after initially getting stuck on the problem. 
