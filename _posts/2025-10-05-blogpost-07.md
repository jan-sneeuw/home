---
title: "Creating a Python Keylogger for Linux Systems"
excerpt: A rough guide on how to build a simple Keylogger for Linux OS, using Python and Bash.
date: 2025-10-05
---

Recently, I've been dabbling a little in malware analysis. Mostly it's quite involved and I only have a basic understanding of some important concepts and tools. So my idea was to start with a more hands-on approach: try to implement some form of malware myself! I came across a video of a very bare-bones Python Windows keylogger and decided I would try the same for Linux systems.

I had a few goals in mind for this project:
- Improve my Python coding skills
- Build a (somewhat) reliable keylogger for Linux systems with either German or English keyboard layouts
- Gain some insight into malware development

> **Note**
> 
> It should be obvious that I will not share the entire source code for my keylogger, as this could easily be abused by adversaries. Instead, I will share only some important snippets to explain the most important syntax and the logic of the program. This project's intention is purely educational.

## 1 Writing the Code

The original motivation for using Python was because of the `evdev` library, which sits at the heart of the logger. In short, this library gives us read access to the raw key/mouse/gamepad input from `/dev/input/`. Altogether, we don't even need to import too many external libraries and modules:
```py
from evdev import InputDevice, list_devices, ecodes
import time
import os
from datetime import datetime
```
I imported `datetime` to fill the logs with additional information later on, and `os` in order to create/edit files on the OS on which the keylogger is executed. 

The basic logic of the logger is as follows:
1. Find all available keyboards in `/dev/input`
2. Determine the layout of the keyboard(s)
3. Declare a key map for either layout
4. Create a text file into which the characters/keys will be written
5. Write data into text file

### 1.1 Determining the Keyboard Layout

The first step is to find all attached keyboards and finding their layout. Otherwise we might work under the assumption that we are logging an English layout, while in reality it may be German, which would significantly obscure the logs in the end. To my surprise, finding the layouts was not entirely straightforward. I had expected the syntax to be something like
```text
find.os: systemsettings > keyboard > language > English [inactive], German [active]
```
and then we could simply pick the active one. Instead, the the source code for this looks like this:
```py
keyboards = []
for device_path in list_devices():
    try:
        device = InputDevice(device_path)
        caps = device.capabilities()
        if ecodes.EV_KEY in caps:
            key_caps = caps[ecodes.EV_KEY]
            if ecodes.KEY_A in key_caps and ecodes.KEY_SPACE in key_caps:
                keyboards.append(device)
    except:
        continue
if not keyboards:
    exit(1)

def get_keyboard_layout():    
    german_map = { ... }
    us_map = { ... }
    if german_map.get(39) == 'รถ':
        return 'de', german_map
    else:
        return 'us', us_map
```
The snippet does the following:
1. Initialise a list into which all available keyboards are written
2. The loop runs over `/dev/input/event0`, `/dev/input/event1` etc. until a keyboard is found
3. Next, we actually check whether the device *is* a keyboard. To do this, we list the *capabilities* of the device and check whether it can generate key press/release events with `if ecodes.EV_KEY in caps:`.
4. If it can, then we check for common keyboard keys (to make sure the device is not a mouse, for instance) with `if ecodes.KEY_A in key_caps and ecodes.KEY_SPACE in key_caps:`. This is more of a sanity check and we could have chosen different keys here.
5. In this case, the device is classified as a keyboard and is appended to `keyboards`. In most cases, this list will obviously contain only one item.

**WIP**





