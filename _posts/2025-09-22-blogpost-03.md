---
title: "XSS in the Real World"
excerpt: How I successfully ran my first stored XSS-attack on a deployed webpage.
date: 2025-09-22
---

In order to practice newly learnt skills about the Burp Suite framework, I contacted a friend who runs the domain [bikeseek.org](https://bikeseek.org/) as a personal project. With his authorization I set out to uncover any vulnerabilities that I could find, using basic web penetration-testing skills. All findings are summarized in [this](/home/uploads/Pentest_Report.pdf) document. The vulnerability from which I learnt the most is what this blogpost is about.

Note: this test was carried out on 20-06-2025, so the results might not be reproducible anymore.

<br>

### First Attempt at XSS Using Burp Suite

To begin with, I set the browser proxy to route traffic through Burp Suite and proceeded to upload an image file via the application’s regular upload functionality. In the intercepted request within Burp’s proxy interceptor, I attempted to manually modify the image’s filename — for instance, replacing it with:

```html
"><script>alert(1);</script>.jpg
```

The line  

```html
<img src="/uploads/user 3 query HASH image.jpg">
```

is included in the HTML of the resulting subdirectory `/my results`, hence the goal was to embed the line  

```html
<img src="/uploads/user_3_query_HASH_"><script>alert(1);</script>.jpg">
```

in the backend, thereby triggering a reflected XSS attack.  

However, the issue with this vector lies in its leading `"` character, which prematurely terminates the `filename="image.jpg"` attribute in the multipart form-data request when I replace *image* with the payload. As a result, the structure of the HTTP request becomes invalid, and the intended injection does not propagate into the rendered page as planned.

<br>

### Successful XSS Using Burp Suite

An alternative approach yielded a successful stored XSS attack on the domain. Here I give a full list explaining how to obtain this result:

1. Proxy the browser to route any traffic through Burp Suite.
2. Upload a vector graphic image with file extension `.svg` to the website and intercept the POST request in Burp Suite.
3. Change the POST content, i.e. the block `<?xml ... </svg>`, to the following snippet, containing a classical Javascript payload:
```xml
<?xml version="1.0" standalone="no"?>
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
  <script type="text/javascript">
    alert(1);
  </script>
</svg>
```
5. Forward the requests and return to the website. The response is a visible error message printed on screen. In our case (we uploaded `bike.svg`), it reads:
  ```text
  An error occurred during search : cannot identify image file ’/home/ec2-user/
  BikeSearch/src/uploads/user_3_query_7a0586d404254425a0e7e5c43050a4c7_bike.svg’
  ```
5. Thus, it seems as though the test-image `bike.svg` has failed to be uploaded to the database. However, if we copy the last part of the file path, i.e. `user_3_query...0a4c7_bike.svg`, navigate to *“View Last Search”* and open an arbitrary image in a new tab, we see that its URL is of the form:
  ```
  https://bikeseek.org/upload/user_3_query_HASH_image.jpg
  ```
6. Now replace the last part of this path file by the copied unique identifier of `bike.svg` from step 5. The URL  
  ```
  https://bikeseek.org/upload/user_3_query_7a0586d404254425a0e7e5c43050a4c7_bike.svg
  ```
  gives the desired XSS attack in our case, as we obtain the expected alert in the browser.

<br>

### Some Observations and Lessons

- It was necessary to upload an `.svg` file, as only these image types support XML, thus enabling us to smuggle in some Javascript code.  
- Despite the unique identifier including the string `user_3_query`, the XSS exploit is not unique to us as a user. It was tested with the owner’s account that whenever they are logged into the domain they can still access the URL from step 6 above and get the alert in the browser.  
- This attack is categorized as a _stored_ XSS vulnerability, since our payload is permanently uploaded in the owner’s database. This was checked with the owner. Nonetheless, the security impact is not extremely high for a few reasons:
  - Any images that users upload are not reused in the backend to search for fitting bikes using ML-methods. Thus, it is impossible for another user to be presented with our malicious file `bike.svg` on their session.  
  - We cannot extend our XSS attack to steal cookies, since the domain has the setting `httponly` set to true, and thus we cannot successfully implement a payload like:
    ```javascript
    alert(document.cookie)
    ```
- One possible way to further exploit this vulnerability is to redirect to a new webpage upon clicking on the malicious URL. This is done with the function:
  ```javascript
  eval(location.href = "https://www.malicious-website.com/")
  ```
  instead of the function `alert(1);` from before.
