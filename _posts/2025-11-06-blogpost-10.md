---
title: "Spawning Shells through Buffer Overflows"
excerpt: A step-by-step analysis of how one can exploit vulnerable programs to spawn a shell out of thin air. 
date: 2025-11-06
---

Some time ago a had an interesting conversation with a colleague who studies cybersecurity: as part of his homework, he explained, he was supposed to abuse buffer-overflows in vulnerable executables or functions at a very low-level in order to spawn a shell seemingly out of nowhere! 

This sounded interesting to me, as he elaborated on some details about registers and stacks which I was roughly able to follow, in part due to the things I learned ever since I sparked an interest in malware analysis and have been going over lots of theory and different rooms, for instance this [Malware Analysis](https://tryhackme.com/module/malware-analysis) room on TryHackMe.

Thus, the goal of this post is to recreate one of these types of vulnerabilities

Since I'm not 100% fluent in the language of assembly and stack frames yet, this challenge also served as a way to familiarise myself more with all of these concepts and workflows. To guarantee a steep learning-curve, I followed [this](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/64-bit-stack-based-buffer-overflow) blog post from the Red Team Notes.


## 1 Vulnerable Program

First and foremost, we will discuss the vulnerable piece of code that we will exploit in this task:
```c
// code from https://blog.techorganic.com/2015/04/10/64-bit-linux-stack-smashing-tutorial-part-1/

#include <stdio.h>
#include <unistd.h>

int vuln() {
    char buf[80];
    int r;
    r = read(0, buf, 400);
    printf("\nRead %d bytes. buf is %s\n", r, buf);
    puts("No shell for you :(");
    return 0;
}

int main(int argc, char *argv[]) {
    printf("Try to exec /bin/sh");
    vuln();
    return 0;
}
```
Roughly speaking, the program prints a message, reads user input, prints how many bytes it read and the input, then prints a cheeky message and exits. If we look more precisely, it first allocates an 80-byte array `buf` on the stack, before writing a given user input into `buf` with the `read` function. 

Notice that `read(0, buf, 400)` tells the system to read up to 400 bytes from file descriptor `0` (standard input) into memory. This will overwrite the stack's contents, specifically, the RBP and the return address, which we can and will be exploit in this challenge.

We compile the code with the following command:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# gcc -fno-stack-protector -z execstack vulnerable.c -o vulnerable
```
The specific options are explained below:
- `-fno-stack-protector`: Tells the compiler not to emit stack-protector code (no stack canaries). Normally, compilers add guard values (“canaries”) around local buffers and check them before returning from functions; if a buffer overflow overwrites the canary, the program aborts. This flag removes that protection so a buffer overflow can overwrite return addresses without being detected by the canary check.
- `-z execstack`: Passed to the linker; requests that the generated ELF binary have an executable stack. On many systems the default is a non-executable stack (NX / DEP), in which case it is often times not as easy to exploit a buffer-overflow.

Compiling our code with these options set is obviously much more insecure. However, for the purpose of this lab this is very much helpful.

Before we run `vulnerable`, we need to make sure that ASLR (Address Space Layout Randomization) is turned off, so studying the virtual addresses later on becomes easier. Generally, its numeric value controls how aggressively the kernel randomizes virtual address space layout for new processes, where 0 = no randomization, 1 = conservative randomization and 2 = full randomization. Run the command
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# echo 0 > /proc/sys/kernel/randomize_va_space
```
to turn ASLR off.

Now if we run the program normally, it simply allows for the user input, returns a cheeky message and terminates the process:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# ./vulnerable
Here is some input!
Try to exec /bin/sh
Read 20 bytes. buf is Here is some input!

No shell for you :(
```


## Technical Analysis

The goal of this chapter is to gain control of the RIP register.

But first: why do we need to control this particular register in the first place? The answer is that RIP is the **R**esgister **I**nstruction **P**ointer, i.e. it tells the CPU which instruction to execute next. If we control the value of RIP, then we might 'abuse' the CPU to execute malicious code.

Since we know about the bug, let's try to force a buffer-overflow by passing a very long string into the user input. First, we create the garbage string and write it into a file:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# python3 -c "import sys; sys.stdout.write('A'*200)" > trash.bin
                                                                                                                                             
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# cat trash.bin 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
```
We will use `gdb` (Gnu Debugger) to analyse the vulnerable exectable, more precisely `gnu-peda` for a better user interface:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/d17b230d-f5f9-4e96-85a6-0e3ebf7acd83"
    alt="image"
    class="clickable-img h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>
<br>

Notice that we open the file with `gdb vulnerable` and then actually run the program with the garbage input in the line that reads `gdb-peda$ r < trash.bin`. We observe the following key points:
- The stack has been overflowed with 'A's, as can be seen in the lines that read
    ```console
    RBP: 0x4141414141414141 ('AAAAAAAA')
    ```
  and
    ```console
    0000| 0x7fffffffe0f8 ('A' <repeats 96 times>, "8\342\377\377\377\177")
    0008| 0x7fffffffe100 ('A' <repeats 88 times>, "8\342\377\377\377\177")
    0016| 0x7fffffffe108 ('A' <repeats 80 times>, "8\342\377\377\377\177")
    0024| 0x7fffffffe110 ('A' <repeats 72 times>, "8\342\377\377\377\177")
    0032| 0x7fffffffe118 ('A' <repeats 64 times>, "8\342\377\377\377\177")
    0040| 0x7fffffffe120 ('A' <repeats 56 times>, "8\342\377\377\377\177")
    0048| 0x7fffffffe128 ('A' <repeats 48 times>, "8\342\377\377\377\177")
    0056| 0x7fffffffe130 ('A' <repeats 40 times>, "8\342\377\377\377\177")
    ```
- It seems as though the RIP (`RIP: 0x5555555551ac (<vuln+83>: ret)`) has not been overflowed
- `gdb` shows the stop location at the ret instruction: `RIP: 0x5555555551ac (<vuln+83>: ret)` — this is the instruction that attempted to return and triggered the crash.

So why is RIP not overflowed? To quote the blog post I am working with:

> The reason the RIP was not overflowed, is because the 'AAAAAAAA' (`0x4141414141414141`) is considered a non-canonical memory address, or, in other words, `0x4141414141414141` is a 64-bit wide address and current CPUs prevent applications and OSes to use 64-bit wide addresses.
>
> Instead, the highest memory addresses programs can use are 48-bit wide addresses and they are capped to `0x00007FFFFFFFFFFF`. This is done to prevent the unnecessary complexity in memory address translations that would not provide much benefit to the OSes or applications as it's very unlikely they would ever need to use all of that 64-bit address space.  







**WIP**
