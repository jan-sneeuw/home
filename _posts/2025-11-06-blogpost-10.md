---
title: "Spawning Shells through Buffer Overflows"
excerpt: A step-by-step analysis of how one can exploit vulnerable programs to spawn a shell out of thin air. 
date: 2025-11-06
---

Some time ago a had an interesting conversation with a colleague who studies cybersecurity: as part of his homework, he explained, he was supposed to abuse buffer-overflows in vulnerable executables or functions at a very low-level in order to spawn a shell seemingly out of nowhere! 

This sounded interesting to me, as he elaborated on some details about registers and stacks which I was roughly able to follow, in part due to the things I learned ever since I sparked an interest in malware analysis and have been going over lots of theory and different rooms, for instance this [Malware Analysis](https://tryhackme.com/module/malware-analysis) room on TryHackMe.

Thus, the goal of this post is to recreate one of these types of vulnerabilities

Since I'm not 100% fluent in the language of assembly and stack frames yet, this challenge also served as a way to familiarise myself more with all of these concepts and workflows. To guarantee a steep learning-curve, I followed [this](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/64-bit-stack-based-buffer-overflow) blog post from the Red Team Notes.


## 1 Vulnerable Program

First and foremost, we will discuss the vulnerable piece of code that we will exploit in this task:
```c
// code from https://blog.techorganic.com/2015/04/10/64-bit-linux-stack-smashing-tutorial-part-1/

#include <stdio.h>
#include <unistd.h>

int vuln() {
    char buf[80];
    int r;
    r = read(0, buf, 400);
    printf("\nRead %d bytes. buf is %s\n", r, buf);
    puts("No shell for you :(");
    return 0;
}

int main(int argc, char *argv[]) {
    printf("Try to exec /bin/sh");
    vuln();
    return 0;
}
```
Roughly speaking, the program prints a message, reads user input, prints how many bytes it read and the input, then prints a cheeky message and exits. If we look more precisely, it first allocates an 80-byte array `buf` on the stack, before writing a given user input into `buf` with the `read` function. 

Notice that `read(0, buf, 400)` tells the system to read up to 400 bytes from file descriptor `0` (standard input) into memory. This will overwrite the stack's contents, specifically, the RBP and the return address, which we can and will be exploit in this challenge.

We compile the code with the following command:
```console
┌──(root㉿kali)-[/home/kali/projects/bin-exploits]
└─# gcc -fno-stack-protector -z execstack vulnerable.c -o vulnerable
```
The specific options are explained below:
- `-fno-stack-protector`: Tells the compiler not to emit stack-protector code (no stack canaries). Normally, compilers add guard values (“canaries”) around local buffers and check them before returning from functions; if a buffer overflow overwrites the canary, the program aborts. This flag removes that protection so a buffer overflow can overwrite return addresses without being detected by the canary check.
- `-z execstack`: Passed to the linker; requests that the generated ELF binary have an executable stack. On many systems the default is a non-executable stack (NX / DEP), in which case it is often times not as easy to exploit a buffer-overflow.

Compiling our code with these options set is obviously much more insecure. However, for the purpose of this lab this is very much helpful.






**WIP**
